import Pair from '../../../../utils/pair';
import Move from '../../move/move';
import Colour from '../colour';
import Piece from './empty';
import { Pieces } from '../piecetype';
import generateKnightMoveOffsets from '../../../../utils/knight';

/**
 * Represents the functionality of a knight. This is inherited from the base Piece.
 *
 * @export
 * @class Knight
 * @typedef {Knight}
 * @extends {Piece}
 */
export default class Knight extends Piece {
    /**
     * Stores the offsets that the knight can travel to.
     * This property is static so that the offsets does not need to be repeatedly generated over and over again
     *
     * @static
     * @type {Pair<number, number>[]}
     */
    static moveOffsets: Pair<number, number>[] = [];
    name = 'knight';
    shortName = 'n';

    /**
     * Creates an instance of Knight.
     * Generates the offset of the knight if it hasn't already been generated by any other knight.
     *
     * @constructor
     * @param {(Colour | undefined)} colour
     */
    constructor(colour: Colour | undefined) {
        super(colour);
        if (Knight.moveOffsets.length == 0)
            Knight.moveOffsets = generateKnightMoveOffsets();
    }

    /**
     * Checking if the current piece can have the move executed on it, given the board as a parameter.
     *
     * @param {Move} move
     * @param {Pieces[][]} board
     * @returns {boolean}
     */
    canBeMovedTo(move: Move, board: Pieces[][]) {
        let offset = this.calculateOffset(move);
        if (!this.basicLegalValidation(move, board)) return false;
        for (let legalOffset of Knight.moveOffsets) {
            if (offset.equals(legalOffset)) return true;
        }
        return false;
    }
}
